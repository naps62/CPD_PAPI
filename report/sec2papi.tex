%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% SECTION 2: ALGORITHM ANALYSIS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Algorithm Analysis}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% SUBSECTION 2.1: ALGORITHM
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The N-Body Algorithm}

In this report, it was required to analyse the performance of the \emph{N-Body} algorithm, which is used to simulate the interaction between a set of objects, and the interactions betweeen them. One example application of this algorithm is simulating the influence that the planet's gravitational force on the other planets in the set, and estimate it's position in the future.

The formula implemented for this analysis is the following:

\begin{IEEEeqnarray}{C}
	\begin{cases}
	{\forall}_{x \in N} \; p_{x}(t + {\Delta}t) = p_{x}(t) + v_{x}(t) + \frac{1}{2}{\Delta}t^{2}a_{x}(t) \nonumber \\
	\\
	\; a_{x}(t) = G \sum_{i=1}^{N} \frac{m_{i} | p_{x} - p{i} |}{| p_{x} - p_{i} |} \nonumber \\
	\end{cases}
\end{IEEEeqnarray}

The formula states that the position of an object $x$ after ${\Delta}t$ units of time, is given by the sum between its previous position, velocity and acceleration. The acceleration is computed iteratively, based on the mass and position of all the other objects in the set. In general, the naive version of this algorithm (the one tested here) runs on $\Theta(N^{2})$. There are much better implementations of this algorithm, down to a complexity of $O(N log(N))$, however they were not the object of study in this article.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% SUBSECTION 2.1: PARTICULAR PROBLEM: SQUARE ROOT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Particular Problem: Square root}

The algorithm requires que calculation of a square root for every interaction, for a total of $N^{2}$ square root calculations for the whole algorithm. This C stantard implementation uses Newton's iterative method, which has an execution time that cannot be estimated easily. Since the focus here is on performance analysis rather that accurate results, it was decided that a different square root implementation should be used.

The selected implementation was taken from a small comparison of square root implementations (see \cite{sqrt}), and it was the one on the article that provided the nearest speed and accuracy compared to the standard implementation, and also had support for double precision floats (some of the implementations didn't because they assumed a 32-bit number and relied on bit shift operations)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% SUBSECTION 2.2: TEST CASES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Test Cases}

Six test cases were choosen, so that two cases could fit on each memory level. \autoref{tab:test_cases} specifies their names and details.

\begin{table}[!htp]
	\begin{center}
		\begin{tabular}{|l|l|l}
		\begin{tabular}
	\end{center}
\end{center}
